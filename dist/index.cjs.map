{"version":3,"file":"index.cjs","mappings":"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","sources":["webpack://treeduxjs/webpack/bootstrap","webpack://treeduxjs/webpack/runtime/define property getters","webpack://treeduxjs/webpack/runtime/hasOwnProperty shorthand","webpack://treeduxjs/webpack/runtime/make namespace object","webpack://treeduxjs/external commonjs \"@reduxjs/toolkit\"","webpack://treeduxjs/./src/Enum/DefaultActionEnum.ts","webpack://treeduxjs/./src/Utility/Objects.ts","webpack://treeduxjs/./src/Treedux.ts","webpack://treeduxjs/./src/Data/Action.ts","webpack://treeduxjs/./src/Data/ReadOnlyStateNode.ts","webpack://treeduxjs/./src/Data/StateNode.ts","webpack://treeduxjs/./src/Data/DataStore.ts","webpack://treeduxjs/./src/Data/AbstractMutator.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@reduxjs/toolkit\");","export var DefaultActionEnum;\n(function (DefaultActionEnum) {\n    DefaultActionEnum[\"BATCH\"] = \"__BATCH__\";\n    DefaultActionEnum[\"SET_BY_KEY_PATH\"] = \"__SET_BY_KEY_PATH__\";\n    DefaultActionEnum[\"DELETE_BY_KEY_PATH\"] = \"__DELETE_BY_KEY_PATH__\";\n})(DefaultActionEnum || (DefaultActionEnum = {}));\n","export class Objects {\n    static isObject(value) {\n        return typeof value === \"object\" && value !== null;\n    }\n    static setByKeyPath(keyPath, value, target) {\n        // Make a copy of the keyPath array to avoid modifying the original array.\n        const path = [...keyPath];\n        // Create a deep copy of the object.\n        const newObject = this.deepCopy(target);\n        // Initialize the current object as the deep copy of the object passed to the function.\n        let currentObj = newObject;\n        // Iterate through the keys in the path.\n        while (path.length > 0) {\n            const key = path.shift();\n            // If we're at the last key in the path, set the value and exit the loop.\n            if (path.length === 0) {\n                if (value === undefined) {\n                    delete currentObj[key];\n                }\n                else {\n                    currentObj[key] = value;\n                }\n                break;\n            }\n            // If the current object doesn't have the key, create an empty object (unless we are trying to delete a key by setting it to undefined)\n            if (!currentObj[key]) {\n                if (typeof value == \"undefined\")\n                    return newObject;\n                currentObj[key] = {};\n            }\n            // Move the reference to the nested object.\n            currentObj = currentObj[key];\n        }\n        // Return the modified deep copy.\n        return newObject;\n    }\n    static deepCopy(object) {\n        // If the object is not an object or null, return it directly.\n        if (typeof object !== \"object\" || object === null) {\n            return object;\n        }\n        // Initialize the result as an array if the input object is an array, otherwise as an object.\n        const result = Array.isArray(object) ? [] : {};\n        // Iterate through the keys of the input object.\n        for (const key in object) {\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                // Recursively call deepCopy to copy the nested properties.\n                result[key] = this.deepCopy(object[key]);\n            }\n        }\n        // Return the cloned object.\n        return result;\n    }\n}\n","import { combineReducers, configureStore, createReducer } from \"@reduxjs/toolkit\";\nimport { DefaultActionEnum } from \"./Enum/DefaultActionEnum\";\nimport { Objects } from \"./Utility/Objects\";\nexport class Treedux {\n    constructor(dataStores, options) {\n        this.subscribers = new Set();\n        this.dataStores = dataStores;\n        options = options || {};\n        const reducerMap = {};\n        // For each data store\n        for (const key in this.dataStores) {\n            // Get the data store instance\n            const dataStore = this.dataStores[key];\n            // Set redux on the data store\n            dataStore.setTreedux(this);\n            // Add reducer the reducer maps\n            reducerMap[key] = createReducer(dataStore.getInitialState(), (builder) => {\n                Object.entries(dataStore.getReducers())\n                    .forEach(([actionType, reducer]) => builder.addCase(actionType, reducer));\n            });\n        }\n        // Combine all data store reducers to create app reducer\n        const appReducer = combineReducers(reducerMap);\n        // Define root reducer\n        const rootReducer = (state, action) => {\n            if (action.type === DefaultActionEnum.BATCH) {\n                return action.payload.reduce(rootReducer, state);\n            }\n            else if (action.type === DefaultActionEnum.SET_BY_KEY_PATH) {\n                const { keyPath, value } = action.payload;\n                return Objects.setByKeyPath(keyPath, value, state);\n            }\n            else if (action.type === DefaultActionEnum.DELETE_BY_KEY_PATH) {\n                const { keyPath } = action.payload;\n                return Objects.setByKeyPath(keyPath, undefined, state);\n            }\n            return appReducer(state, action);\n        };\n        this.storeInstance = configureStore({\n            reducer: rootReducer,\n            preloadedState: options.initialState\n        });\n        this.storeInstance.subscribe(() => this.notifySubscribers());\n    }\n    static init(dataStores, options) {\n        return new Treedux(dataStores, options);\n    }\n    get state() {\n        const storeObj = {};\n        for (const key in this.dataStores) {\n            storeObj[key] = this.dataStores[key].state;\n        }\n        return storeObj;\n    }\n    getState() {\n        return this.storeInstance.getState();\n    }\n    subscribe(subscriber) {\n        this.subscribers.add(subscriber);\n        return () => this.subscribers.delete(subscriber);\n    }\n    dispatch(...actions) {\n        this.storeInstance.dispatch({\n            type: DefaultActionEnum.BATCH,\n            payload: actions.map(action => action.serialize())\n        });\n    }\n    notifySubscribers() {\n        this.subscribers.forEach(subscriber => subscriber());\n    }\n}\n","export class Action {\n    constructor(action, treedux) {\n        this.type = action.type;\n        this.payload = action.payload;\n        this.treedux = treedux;\n    }\n    static create(action, treedux) {\n        return new Action(action, treedux);\n    }\n    dispatch() {\n        this.treedux.dispatch(this);\n    }\n    serialize() {\n        return { type: this.type, payload: this.payload };\n    }\n}\n","import { Objects } from \"../Utility/Objects\";\nexport class ReadOnlyStateNode {\n    constructor(options, treedux) {\n        this.keyPath = [];\n        this.treedux = treedux;\n        this.keyPath = options.keyPath;\n    }\n    static create(options, treedux) {\n        return (new ReadOnlyStateNode(options, treedux)).createProxy();\n    }\n    get() {\n        const keys = [...this.keyPath];\n        let value = this.treedux.getState();\n        while (keys.length > 0) {\n            // Get the next key\n            const key = keys.shift();\n            // If there is a value for the key, use that\n            if (Objects.isObject(value)) {\n                value = value[key];\n            }\n            else {\n                this.lastKnownValue = undefined;\n                return this.lastKnownValue;\n            }\n        }\n        this.lastKnownValue = value;\n        return this.lastKnownValue;\n    }\n    subscribe(callback) {\n        let currentValue = this.lastKnownValue;\n        return this.treedux.subscribe(() => {\n            const newValue = this.get();\n            if (JSON.stringify(newValue) === JSON.stringify(currentValue))\n                return;\n            currentValue = newValue;\n            callback(currentValue);\n        });\n    }\n    byKey(key) {\n        if (!key)\n            throw `Key must be provided to byKey method.`;\n        return ReadOnlyStateNode.create({\n            keyPath: this.keyPath.concat([key.toString()])\n        }, this.treedux);\n    }\n    createProxy() {\n        return new Proxy(this, {\n            get(self, property) {\n                if (typeof property !== \"string\")\n                    return null;\n                // If property is a default method, return it\n                if (typeof self[property] === \"function\")\n                    return self[property].bind(self);\n                // Default to returning a new StateNode\n                return ReadOnlyStateNode.create({\n                    keyPath: self.keyPath.concat(property)\n                }, self.treedux);\n            }\n        });\n    }\n}\n","import { DefaultActionEnum } from \"../Enum/DefaultActionEnum\";\nimport { Objects } from \"../Utility/Objects\";\nimport { Action } from \"./Action\";\nimport { ReadOnlyStateNode } from \"./ReadOnlyStateNode\";\nexport class StateNode {\n    constructor(options, treedux) {\n        this.keyPath = [];\n        this.treedux = treedux;\n        this.keyPath = options.keyPath;\n        this.mutators = options.mutators;\n    }\n    static create(options, treedux) {\n        return (new StateNode(options, treedux)).createProxy();\n    }\n    get() {\n        const keys = [...this.keyPath];\n        let value = this.treedux.getState();\n        while (keys.length > 0) {\n            // Get the next key\n            const key = keys.shift();\n            // If there is a value for the key, use that\n            if (Objects.isObject(value) && value[key] !== undefined) {\n                value = value[key];\n            }\n            else {\n                this.lastKnownValue = undefined;\n                return this.lastKnownValue;\n            }\n        }\n        this.lastKnownValue = value;\n        return this.lastKnownValue;\n    }\n    set(value) {\n        return Action.create({\n            type: DefaultActionEnum.SET_BY_KEY_PATH,\n            payload: { keyPath: this.keyPath, value: value }\n        }, this.treedux);\n    }\n    subscribe(callback) {\n        let currentValue = this.lastKnownValue;\n        return this.treedux.subscribe(() => {\n            const newValue = this.get();\n            if (JSON.stringify(newValue) === JSON.stringify(currentValue))\n                return;\n            currentValue = newValue;\n            callback(currentValue);\n        });\n    }\n    byKey(key) {\n        if (!key)\n            throw `Key must be provided to byKey method.`;\n        return StateNode.create({\n            keyPath: this.keyPath.concat([key.toString()]),\n            mutators: this.mutators\n        }, this.treedux);\n    }\n    delete() {\n        return Action.create({\n            type: DefaultActionEnum.DELETE_BY_KEY_PATH,\n            payload: { keyPath: this.keyPath }\n        }, this.treedux);\n    }\n    toReadOnly() {\n        return ReadOnlyStateNode.create({ keyPath: this.keyPath }, this.treedux);\n    }\n    createProxy() {\n        return new Proxy(this, {\n            get(self, property) {\n                if (typeof property !== \"string\")\n                    return null;\n                const mutatorMethod = self.getMutatorMethod(property);\n                // If mutator method exists, return it\n                if (mutatorMethod)\n                    return mutatorMethod;\n                // If property is a default method, return it\n                if (typeof self[property] === \"function\")\n                    return self[property].bind(self);\n                // Default to returning a new StateNode\n                return StateNode.create({\n                    keyPath: self.keyPath.concat(property),\n                    mutators: self.mutators && self.mutators[property] ? self.mutators[property] : {}\n                }, self.treedux);\n            }\n        });\n    }\n    getMutatorMethod(methodName) {\n        // If mutator method doesn't exist, return null\n        if (!this.mutators || !this.mutators.hasOwnProperty(methodName) || typeof this.mutators[methodName] !== \"function\")\n            return null;\n        const mutatorCreator = this.mutators[methodName];\n        const mutator = mutatorCreator(this.treedux);\n        return mutator.getAction.bind(mutator);\n    }\n}\n","import { StateNode } from \"./StateNode\";\nexport class DataStore {\n    constructor(key, options) {\n        this.KEY = key;\n        this.initialState = options.initialState;\n        this.mutators = options.mutators;\n    }\n    static create(key, options) {\n        return new DataStore(key, options);\n    }\n    get state() {\n        const options = { keyPath: [this.KEY], mutators: this.mutators };\n        return StateNode.create(options, this.treedux);\n    }\n    setTreedux(treedux) {\n        this.treedux = treedux;\n        return this;\n    }\n    getInitialState() {\n        return this.initialState;\n    }\n    getReducers() {\n        return this.hydrateReducersFromMutators({}, this.mutators);\n    }\n    hydrateReducersFromMutators(reducerMap, mutators) {\n        for (const key in mutators) {\n            const mutatorCreator = mutators[key];\n            if (typeof mutatorCreator === \"object\") {\n                this.hydrateReducersFromMutators(reducerMap, mutatorCreator);\n            }\n            else {\n                const mutator = mutatorCreator(this.treedux);\n                if (reducerMap[mutator.getType()])\n                    throw `Cannot add reducer. Action type already registered: ${key}`;\n                reducerMap[mutator.getType()] = (...args) => {\n                    return mutator.reduce.call(mutator, ...args);\n                };\n            }\n        }\n        return reducerMap;\n    }\n}\n","export class AbstractMutator {\n    constructor(treedux) {\n        this.treedux = treedux;\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","DefaultActionEnum","Objects","isObject","setByKeyPath","keyPath","target","path","newObject","this","deepCopy","currentObj","length","shift","undefined","object","result","Array","isArray","Treedux","constructor","dataStores","options","subscribers","Set","reducerMap","dataStore","setTreedux","createReducer","getInitialState","builder","entries","getReducers","forEach","actionType","reducer","addCase","appReducer","combineReducers","rootReducer","state","action","type","BATCH","payload","reduce","SET_BY_KEY_PATH","DELETE_BY_KEY_PATH","storeInstance","configureStore","preloadedState","initialState","subscribe","notifySubscribers","init","storeObj","getState","subscriber","add","delete","dispatch","actions","map","serialize","Action","treedux","create","ReadOnlyStateNode","createProxy","keys","lastKnownValue","callback","currentValue","newValue","JSON","stringify","byKey","concat","toString","Proxy","self","property","bind","StateNode","mutators","set","toReadOnly","getMutatorMethod","methodName","mutator","mutatorCreator","getAction","DataStore","KEY","hydrateReducersFromMutators","getType","args","AbstractMutator"],"sourceRoot":""}