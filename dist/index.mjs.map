{"version":3,"file":"index.mjs","mappings":"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","sources":["webpack://treeduxjs/webpack/bootstrap","webpack://treeduxjs/webpack/runtime/define property getters","webpack://treeduxjs/webpack/runtime/hasOwnProperty shorthand","webpack://treeduxjs/external module \"@reduxjs/toolkit\"","webpack://treeduxjs/./src/Enum/DefaultActionEnum.ts","webpack://treeduxjs/./src/Utility/Objects.ts","webpack://treeduxjs/./src/Treedux.ts","webpack://treeduxjs/./src/Data/Action.ts","webpack://treeduxjs/./src/Data/StateNode.ts","webpack://treeduxjs/./src/Data/DataStore.ts","webpack://treeduxjs/./src/Data/AbstractMutator.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }\nvar y = x => () => x\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"combineReducers\"]: () => __WEBPACK_EXTERNAL_MODULE__reduxjs_toolkit_fb094368__.combineReducers, [\"configureStore\"]: () => __WEBPACK_EXTERNAL_MODULE__reduxjs_toolkit_fb094368__.configureStore, [\"createReducer\"]: () => __WEBPACK_EXTERNAL_MODULE__reduxjs_toolkit_fb094368__.createReducer });","export var DefaultActionEnum;\n(function (DefaultActionEnum) {\n    DefaultActionEnum[\"BATCH\"] = \"__BATCH__\";\n    DefaultActionEnum[\"SET_BY_KEY_PATH\"] = \"__SET_BY_KEY_PATH__\";\n})(DefaultActionEnum || (DefaultActionEnum = {}));\n","export class Objects {\n    static isObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    static setByKeyPath(keyPath, value, target) {\n        // Check if the keyPath is empty, and if so, throw an error.\n        if (keyPath.length === 0) {\n            throw new Error(\"Key path should not be empty.\");\n        }\n        // Make a copy of the keyPath array to avoid modifying the original array.\n        const path = [...keyPath];\n        // Create a deep copy of the object.\n        const newObject = this.deepCopy(target);\n        // Initialize the current object as the deep copy of the object passed to the function.\n        let currentObj = newObject;\n        // Iterate through the keys in the path.\n        while (path.length > 0) {\n            const key = path.shift();\n            // If we're at the last key in the path, set the value and exit the loop.\n            if (path.length === 0) {\n                if (value === undefined) {\n                    delete currentObj[key];\n                }\n                else {\n                    currentObj[key] = value;\n                }\n                break;\n            }\n            // If the current object doesn't have the key, create an empty object (unless we are trying to delete a key by setting it to undefined)\n            if (!currentObj[key]) {\n                if (typeof value == \"undefined\")\n                    return newObject;\n                currentObj[key] = {};\n            }\n            // Move the reference to the nested object.\n            currentObj = currentObj[key];\n        }\n        // Return the modified deep copy.\n        return newObject;\n    }\n    static deepCopy(object) {\n        // If the object is not an object or null, return it directly.\n        if (typeof object !== 'object' || object === null) {\n            return object;\n        }\n        // Initialize the result as an array if the input object is an array, otherwise as an object.\n        const result = Array.isArray(object) ? [] : {};\n        // Iterate through the keys of the input object.\n        for (const key in object) {\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                // Recursively call deepCopy to copy the nested properties.\n                result[key] = this.deepCopy(object[key]);\n            }\n        }\n        // Return the cloned object.\n        return result;\n    }\n}\n","import { combineReducers, configureStore, createReducer } from \"@reduxjs/toolkit\";\nimport { DefaultActionEnum } from \"./Enum/DefaultActionEnum\";\nimport { Objects } from \"./Utility/Objects\";\nexport class Treedux {\n    constructor(dataStores, options) {\n        this.dataStores = dataStores;\n        options = options || {};\n        const reducerMap = {};\n        // For each data store\n        for (const key in this.dataStores) {\n            // Get the data store instance\n            const dataStore = this.dataStores[key];\n            // Set redux on the data store\n            dataStore.setTreedux(this);\n            // Add reducer the reducer maps\n            reducerMap[key] = createReducer(dataStore.getInitialState(), (builder) => {\n                Object.entries(dataStore.getReducers()).forEach(([actionType, reducer]) => builder.addCase(actionType, reducer));\n            });\n        }\n        // Combine all data store reducers to create app reducer\n        const appReducer = combineReducers(reducerMap);\n        // Define root reducer\n        const rootReducer = (state, action) => {\n            if (action.type === DefaultActionEnum.BATCH) {\n                return action.payload.reduce(rootReducer, state);\n            }\n            else if (action.type === DefaultActionEnum.SET_BY_KEY_PATH) {\n                const { keyPath, value } = action.payload;\n                return Objects.setByKeyPath(keyPath, value, state);\n            }\n            return appReducer(state, action);\n        };\n        this.storeInstance = configureStore({\n            reducer: rootReducer,\n            preloadedState: options.initialState\n        });\n    }\n    static init(dataStores, options) {\n        return new Treedux(dataStores, options);\n    }\n    get state() {\n        if (!this.storeInstance)\n            throw \"Cannot get store. Redux store has not been initialized.\";\n        const storeObj = {};\n        for (const key in this.dataStores) {\n            storeObj[key] = this.dataStores[key].state;\n        }\n        return storeObj;\n    }\n    getState() {\n        if (!this.storeInstance)\n            throw \"Cannot get state. Redux store has not been initialized.\";\n        return this.storeInstance.getState();\n    }\n    subscribe(listener) {\n        if (!this.storeInstance)\n            throw \"Cannot subscribe to store. Redux store has not been initialized.\";\n        return this.storeInstance.subscribe(listener);\n    }\n    dispatch(...actions) {\n        if (!this.storeInstance)\n            throw \"Cannot dispatch action. Redux store has not been initialized.\";\n        this.storeInstance.dispatch({\n            type: DefaultActionEnum.BATCH,\n            payload: actions.map(action => action.serialize()),\n        });\n    }\n}\n","export class Action {\n    constructor(action, treedux) {\n        this.type = action.type;\n        this.payload = action.payload;\n        this.treedux = treedux;\n    }\n    static create(action, treedux) {\n        return new Action(action, treedux);\n    }\n    dispatch() {\n        this.treedux.dispatch(this);\n    }\n    serialize() {\n        return { type: this.type, payload: this.payload };\n    }\n}\n","import { DefaultActionEnum } from \"../Enum/DefaultActionEnum\";\nimport { Objects } from \"../Utility/Objects\";\nimport { Action } from \"./Action\";\nexport class StateNode {\n    constructor(options, treedux) {\n        this.keyPath = [];\n        this.treedux = treedux;\n        this.keyPath = options.keyPath;\n        this.mutators = options.mutators;\n    }\n    static create(options, treedux) {\n        return (new StateNode(options, treedux)).createProxy();\n    }\n    get() {\n        const keys = [...this.keyPath];\n        const state = this.treedux.getState();\n        if (keys.length === 0)\n            return state;\n        let value = state;\n        while (keys.length > 0) {\n            // Get the next key\n            const key = keys.shift();\n            // If there is a value for the key, use that\n            if (Objects.isObject(value) && value[key] !== undefined) {\n                value = value[key];\n            }\n            else {\n                this.lastKnownValue = null;\n                return this.lastKnownValue;\n            }\n        }\n        this.lastKnownValue = value;\n        return this.lastKnownValue;\n    }\n    set(value) {\n        return Action.create({\n            type: DefaultActionEnum.SET_BY_KEY_PATH,\n            payload: { keyPath: this.keyPath, value: value }\n        }, this.treedux);\n    }\n    subscribe(callback) {\n        let currentValue = this.lastKnownValue;\n        return this.treedux.subscribe(() => {\n            const newValue = this.get();\n            if (JSON.stringify(newValue) === JSON.stringify(currentValue))\n                return;\n            currentValue = newValue;\n            callback(currentValue);\n        });\n    }\n    createProxy() {\n        return new Proxy(this, {\n            get(self, property) {\n                if (typeof property !== 'string')\n                    return null;\n                const mutatorMethod = self.getMutatorMethod(property);\n                // If mutator method exists, return it\n                if (mutatorMethod)\n                    return mutatorMethod;\n                // If property is a default method, return it\n                if (typeof self[property] === 'function')\n                    return self[property].bind(self);\n                // Default to returning a new StateNode\n                return StateNode.create({\n                    keyPath: self.keyPath.concat(property),\n                    mutators: self.mutators && self.mutators[property] ? self.mutators[property] : {}\n                }, self.treedux);\n            },\n        });\n    }\n    getMutatorMethod(methodName) {\n        // If mutator method doesn't exist, return null\n        if (!this.mutators || !this.mutators.hasOwnProperty(methodName) || typeof this.mutators[methodName] !== 'function')\n            return null;\n        const mutatorCreator = this.mutators[methodName];\n        const mutator = mutatorCreator(this.treedux);\n        return mutator.getAction.bind(mutator);\n    }\n    getMutatorMethods() {\n        const mutatorCreators = this.mutators || {};\n        const mutatorMethods = {};\n        for (const methodName in mutatorCreators) {\n            mutatorMethods[methodName] = this.getMutatorMethod(methodName);\n        }\n        return mutatorMethods;\n    }\n}\n","import { StateNode } from \"./StateNode\";\nexport class DataStore {\n    constructor(key, options) {\n        this.KEY = key;\n        this.initialState = options.initialState;\n        this.mutators = options.mutators;\n    }\n    static create(key, options) {\n        return new DataStore(key, options);\n    }\n    get state() {\n        const options = { keyPath: [this.KEY], mutators: this.mutators };\n        return StateNode.create(options, this.treedux);\n    }\n    setTreedux(treedux) {\n        this.treedux = treedux;\n        return this;\n    }\n    getInitialState() {\n        return this.initialState;\n    }\n    getReducers() {\n        return this.hydrateReducersFromMutators({}, this.mutators);\n    }\n    hydrateReducersFromMutators(reducerMap, mutators) {\n        for (const key in mutators) {\n            const mutatorCreator = mutators[key];\n            if (typeof mutatorCreator === 'object') {\n                this.hydrateReducersFromMutators(reducerMap, mutatorCreator);\n            }\n            else {\n                if (reducerMap[key])\n                    throw `Cannot add reducer. Action type already registered: ${key}`;\n                const mutator = mutatorCreator(this.treedux);\n                reducerMap[mutator.getType()] = mutator.reduce;\n            }\n        }\n        return reducerMap;\n    }\n}\n","export class AbstractMutator {\n    constructor(treedux) {\n        this.treedux = treedux;\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","y","__WEBPACK_EXTERNAL_MODULE__reduxjs_toolkit_fb094368__","combineReducers","configureStore","createReducer","x","d","DefaultActionEnum","Objects","static","value","keyPath","target","length","Error","path","newObject","this","deepCopy","currentObj","shift","undefined","object","result","Array","isArray","Treedux","constructor","dataStores","options","reducerMap","dataStore","setTreedux","getInitialState","builder","entries","getReducers","forEach","actionType","reducer","addCase","appReducer","rootReducer","state","action","type","BATCH","payload","reduce","SET_BY_KEY_PATH","setByKeyPath","storeInstance","preloadedState","initialState","storeObj","getState","subscribe","listener","dispatch","actions","map","serialize","Action","treedux","StateNode","mutators","createProxy","keys","isObject","lastKnownValue","set","create","callback","currentValue","newValue","JSON","stringify","Proxy","self","property","getMutatorMethod","bind","concat","methodName","mutator","mutatorCreator","getAction","getMutatorMethods","mutatorCreators","mutatorMethods","DataStore","KEY","hydrateReducersFromMutators","getType","AbstractMutator"],"sourceRoot":""}