import*as t from"@reduxjs/toolkit";var e={d:(t,s)=>{for(var r in s)e.o(s,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:s[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},s={};e.d(s,{c9:()=>l,aU:()=>u,KT:()=>d,Nj:()=>i,nu:()=>c,fO:()=>h});const r=(o={combineReducers:()=>t.combineReducers,configureStore:()=>t.configureStore,createReducer:()=>t.createReducer},a={},e.d(a,o),a);var o,a,i;!function(t){t.BATCH="__BATCH__",t.SET_BY_KEY_PATH="__SET_BY_KEY_PATH__"}(i||(i={}));class n{static isObject(t){return"object"==typeof t&&null!==t}static setByKeyPath(t,e,s){if(0===t.length)throw new Error("Key path should not be empty.");const r=[...t],o=this.deepCopy(s);let a=o;for(;r.length>0;){const t=r.shift();if(0===r.length){void 0===e?delete a[t]:a[t]=e;break}if(!a[t]){if(void 0===e)return o;a[t]={}}a=a[t]}return o}static deepCopy(t){if("object"!=typeof t||null===t)return t;const e=Array.isArray(t)?[]:{};for(const s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=this.deepCopy(t[s]));return e}}class h{constructor(t,e){this.dataStores=t,e=e||{};const s={};this.hooks=e.hooks;for(const t in this.dataStores){const e=this.dataStores[t];e.setTreedux(this),s[t]=(0,r.createReducer)(e.getInitialState(),(t=>{Object.entries(e.getReducers()).forEach((([e,s])=>t.addCase(e,s)))})),e.setHooks(this.hooks)}const o=(0,r.combineReducers)(s),a=(t,e)=>{if(e.type===i.BATCH)return e.payload.reduce(a,t);if(e.type===i.SET_BY_KEY_PATH){const{keyPath:s,value:r}=e.payload;return n.setByKeyPath(s,r,t)}return o(t,e)};this.storeInstance=(0,r.configureStore)({reducer:a,preloadedState:e.initialState})}static init(t,e){return new h(t,e)}get state(){if(!this.storeInstance)throw"Cannot get store. Redux store has not been initialized.";const t={};for(const e in this.dataStores)t[e]=this.dataStores[e].state;return t}getState(){if(!this.storeInstance)throw"Cannot get state. Redux store has not been initialized.";return this.storeInstance.getState()}subscribe(t){if(!this.storeInstance)throw"Cannot subscribe to store. Redux store has not been initialized.";return this.storeInstance.subscribe(t)}dispatch(...t){if(!this.storeInstance)throw"Cannot dispatch action. Redux store has not been initialized.";this.storeInstance.dispatch({type:i.BATCH,payload:t.map((t=>t.serialize()))})}}class u{constructor(t,e){this.type=t.type,this.payload=t.payload,this.treedux=e}static create(t,e){return new u(t,e)}dispatch(){this.treedux.dispatch(this)}serialize(){return{type:this.type,payload:this.payload}}}class c{constructor(t,e){this.keyPath=[],this.treedux=e,this.keyPath=t.keyPath,this.mutators=t.mutators,this.hooks=t.hooks}static create(t,e){return new c(t,e).createProxy()}get(){const t=[...this.keyPath],e=this.treedux.getState();if(0===t.length)return e;let s=e;for(;t.length>0;){const e=t.shift();if(!n.isObject(s)||void 0===s[e])return this.lastKnownValue=null,this.lastKnownValue;s=s[e]}return this.lastKnownValue=s,this.lastKnownValue}set(t){return u.create({type:i.SET_BY_KEY_PATH,payload:{keyPath:this.keyPath,value:t}},this.treedux)}subscribe(t){let e=this.lastKnownValue;return this.treedux.subscribe((()=>{const s=this.get();JSON.stringify(s)!==JSON.stringify(e)&&(e=s,t(e))}))}use(){if(!this.hooks)throw"Cannot use StateNode.use() - hooks have not been set.";const[t,e]=this.hooks.useState(this.get());return this.hooks.useEffect((()=>this.subscribe(e))),Object.assign({value:t,set:this.set.bind(this)},this.getMutatorMethods())}createProxy(){return new Proxy(this,{get(t,e){if("string"!=typeof e)return null;return t.getMutatorMethod(e)||("function"==typeof t[e]?t[e].bind(t):c.create({keyPath:t.keyPath.concat(e),mutators:t.mutators&&t.mutators[e]?t.mutators[e]:{},hooks:t.hooks},t.treedux))}})}getMutatorMethod(t){if(!this.mutators||!this.mutators.hasOwnProperty(t)||"function"!=typeof this.mutators[t])return null;const e=(0,this.mutators[t])(this.treedux);return e.getAction.bind(e)}getMutatorMethods(){const t=this.mutators||{},e={};for(const s in t)e[s]=this.getMutatorMethod(s);return e}}class d{constructor(t,e){this.KEY=t,this.initialState=e.initialState,this.mutators=e.mutators}static create(t,e){return new d(t,e)}get state(){const t={keyPath:[this.KEY],mutators:this.mutators,hooks:this.hooks};return c.create(t,this.treedux)}setTreedux(t){return this.treedux=t,this}setHooks(t){return this.hooks=t,this}getInitialState(){return this.initialState}getReducers(){return this.hydrateReducersFromMutators({},this.mutators)}hydrateReducersFromMutators(t,e){for(const s in e){const r=e[s];if("object"==typeof r)this.hydrateReducersFromMutators(t,r);else{if(t[s])throw`Cannot add reducer. Action type already registered: ${s}`;const e=r(this.treedux);t[e.getType()]=e.reduce}}return t}}class l{constructor(t){this.treedux=t}}var y=s.c9,f=s.aU,p=s.KT,b=s.Nj,g=s.nu,k=s.fO;export{y as AbstractMutator,f as Action,p as DataStore,b as DefaultActionEnum,g as StateNode,k as Treedux};
//# sourceMappingURL=index.mjs.map